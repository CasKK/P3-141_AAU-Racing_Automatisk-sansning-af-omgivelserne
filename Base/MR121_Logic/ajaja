inputVectorsBTurn = [[-368.0, 540.0, 0],
                    [-365.0, 1100.0, 0],
                    [-403.0, 2250.0, 0],
                    [-1.0, 3680.0, 0],
                    [1044.0, 4540.0, 0],
                    [1847.0, 4690.0, 0],
                    [2477.0, 4800.0, 0],
                    [2900.0, 5200.0, 0],
                    [3000.0, 5600.0, 0],
                    [2910.0, 6300.0, 0]]
inputVectorsYTurn = [[353.0, 670.0, 1],
                    [377.0, 1330.0, 1],
                    [351.0, 2150.0, 1],
                    [779.0, 3230.0, 1],
                    [1353.0, 3710.0, 1],
                    [1977.0, 3890.0, 1],
                    [3000.0, 4000.0, 1],
                    [3700.0, 4700.0, 1],
                    [3800.0, 5700.0, 1],
                    [3810.0, 6300.0, 1]]

car = [0,1500]

def closestNP1(vectorList):########### Sort point list based on distance from (0,0) ############
    vectorList = copy.deepcopy(vectorList)
    for i, vector in enumerate(vectorList):
        result = np.sqrt(vector[0]**2 + vector[1]**2)
        if i < len(vectorList)-1:
            nextVector = vectorList[i+1]
            nextDist = np.sqrt((vector[0] - nextVector[0])**2 + (vector[1] - nextVector[1])**2)
        else:
            nextDist = 10000
        vectorList[i].extend([result, nextDist])
    vectorList = np.array(sorted(vectorList, key=lambda x: x[-2]))
    return vectorList


def calculateCenters(distanceListA, distanceListB):############# Canculate center points from two point lists ############
    centers = [car]
    distanceListA = copy.deepcopy(distanceListA)
    distanceListB = copy.deepcopy(distanceListB)
    for i, (vecA, vecB) in enumerate(zip(distanceListA, distanceListB)):
        centers.append([((vecA[0] - vecB[0]) / 2) + vecB[0], ((vecA[1] - vecB[1]) / 2) + vecB[1]])
        if i < len(distanceListA) - 1:
            next_vecA = distanceListA[i + 1]
            centers.append([((next_vecA[0] - vecB[0]) / 2) + vecB[0], ((next_vecA[1] - vecB[1]) / 2) + vecB[1]])
        if i < len(distanceListB) - 1:
            next_vecB = distanceListB[i + 1]
            centers.append([((next_vecB[0] - vecA[0]) / 2) + vecA[0], ((next_vecB[1] - vecA[1]) / 2) + vecA[1]])
    for i, center in enumerate(centers):
        centers[i].append(np.sqrt(center[0]**2 + center[1]**2))
    centers = np.array(sorted(centers, key=lambda x: x[-2]))
    return centers


def BSpline(points):########### Make and fit Basis-spline ############### 
    d = 0
    t = [0]
    for i, point in enumerate(points):
        if i < len(points)-1:
            nextPoint = points[i+1]
            d += (np.sqrt((point[0] - nextPoint[0])**2 + (point[1] - nextPoint[1])**2)) 
            t = np.append(t, d)
    t = t / t[-1]  # normalize between 0--1
    
    tck, u = splprep([points[:,0], points[:,1]], u=t, s=50000, k=5)
    u_fine = np.linspace(0, 1, 800)
    x_u, y_u = splev(u_fine, tck)
    dx_u, dy_u = splev(u_fine, tck, der=1)
    ddx_u, ddy_u = splev(u_fine, tck, der=2)
    
    s = np.sqrt(dx_u**2 + dy_u**2)
    kp = (dx_u * ddy_u - dy_u * ddx_u) / (s**3)
    v_max = np.sqrt(1 / (np.abs(kp) + 1e-6))
    v_max = np.clip(v_max, 0, 80)
    return v_max, kp, x_u, y_u, dx_u, dy_u

def main():
    global distanceSortedPointsB, distanceSortedPointsY
    distanceSortedPointsB = closestNP1(inputVectorsBTurn)
    distanceSortedPointsY = closestNP1(inputVectorsYTurn)

    global centers
    centers = calculateCenters(distanceSortedPointsB, distanceSortedPointsY)

if __name__ == "__main__":
    for i in range(20):
        main()